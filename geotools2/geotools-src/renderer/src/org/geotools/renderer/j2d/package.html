<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <TITLE>package org.geotools.renderer.j2d</TITLE>
  </HEAD>
  <BODY>
    <P ALIGN="justify">Couches à afficher sur une carte à l'aide de Java2D.
    Ces couches peuvent être des points indiquant les positions des stations,
    des flèches de courants, des ellipses de marées, des images satellitaires,
    des courbes de pressions, l'échelle de la carte, des frontières géopolitiques,
    des villes, etc. Comme cette bibliothèque ne peut pas embrasser toutes les
    étendues des possibilités, les quelques classes qu'elle propose sont conçues
    de façon à faciliter autant que possible la tâche du programmeur qui voudrait
    les étendre. Le fonctionnement de ce paquet présente quelques similitudes
    avec les composantes AWT, qui servent à construire une interface utilisateur.
    Pour mieux comprendre le fonctionnement de ce paquet, il est utile de faire
    un parallèle entre celui-ci et AWT. Cette documentation suppose que le
    lecteur est familier avec le paquet <CODE>java.awt</CODE>. Une attention
    toute particulière devrait être apportée aux systèmes de coordonnées des
    objets {@link java.awt.Graphics2D}.</P>

    <P>&nbsp;</P><A NAME="awt"><TABLE width="100%" bgcolor=burlywood cellpadding=6>
    <TR><TD><FONT size=4><STRONG>Rappel de quelques notions de AWT</STRONG></FONT></TD></TR></TABLE>

    <P ALIGN=justify>Une application fenêtrée contient une liste de composantes
    formant l'interface utilisateur. Chaque type de composante (bouton, barre de
    défilement, etc.) est représentée par une classe spécialisée ({@link java.awt.Button},
    {@link java.awt.Scrollbar}, etc.) qui dérive obligatoirement de la classe
    {@link java.awt.Component}. Quand le système a déterminé qu'il faut redessiner une
    composante, il appelle automatiquement la méthode <CODE>paint(...)</CODE> de celle-ci.
    Aux méthodes <CODE>paint(...)</CODE> de chacune des composantes, le système transmet
    un même objet {@link java.awt.Graphics2D} temporaire qu'il aura préalablement créé
    et configuré comme suit:</P>

    <P ALIGN="center">
    <TABLE BORDER =1 cellpadding=4>
      <TR>
        <TD ALIGN="right" bgcolor=bisque><strong>Origine&nbsp;(0,0)&nbsp;des&nbsp;axes:</strong></TD>
        <TD bgcolor=lightgoldenrodyellow>Coin supérieur gauche de l'écran ou du papier d'imprimante.</TD>
      </TR>
      <TR>
        <TD ALIGN="right" bgcolor=bisque><strong>Direction&nbsp;des&nbsp;axes:</strong></TD>
        <TD bgcolor=lightgoldenrodyellow>Les <var>x</var> croissent vers la droite
            et les <var>y</var> vers le <strong><U>bas</U></strong>.</TD>
      </TR>
      <TR>
        <TD ALIGN="right" bgcolor=bisque><strong>Unités&nbsp;des&nbsp;axes:</strong></TD>
        <TD bgcolor=lightgoldenrodyellow>Les pixels (sorties à l'écran) ou environ
            1/72 de pouce (sorties à l'imprimante).</TD>
      </TR>
      <TR>
        <TD ALIGN="right" bgcolor=bisque><strong>Épaisseur&nbsp;des&nbsp;lignes:</strong></TD>
        <TD bgcolor=lightgoldenrodyellow>Un pixel (sorties à l'écran) ou environ
            1/72 de pouce (sorties à l'imprimante).</TD>
      </TR>
    </TABLE>
    <br><b>Tableau 1: Configuration de {@link java.awt.Graphics2D} lors du traçage
           des composantes AWT</b></P>

    <P ALIGN=justify>Cette configuration convient très bien à l'écriture de texte.
    Ainsi, un texte de 12 unités de haut aura une hauteur de 12 pixels à l'écran
    ou de 1/6 de pouces à l'impression. Les méthodes <CODE>paint(...)</CODE>
    peuvent changer temporairement la configuration de {@link java.awt.Graphics2D}
    lors d'un traçage, mais doivent le remettre dans son état initial (tableau 1)
    lorsqu'elles se terminent.</P>

    <P>&nbsp;</P><A NAME="map"><TABLE width="100%" bgcolor=burlywood cellpadding=6>
    <TR><TD><FONT size=4><STRONG>Notions de <CODE>org.geotools.renderer.j2d</CODE>
    calquées sur celles de AWT</STRONG></FONT></TD></TR></TABLE>

    <P ALIGN="justify">Un objet {@link org.geotools.renderer.j2d.Renderer} peut
    contenir une liste de couches représentant les informations que l'on place
    sur une carte. Chaque type de couche (stations, échelle de la carte, etc.)
    est représenté par une classe spécialisée ({@link org.geotools.renderer.j2d.RenderedMarks},
    {@link org.geotools.renderer.j2d.RenderedMapScale}, etc.) qui dérive obligatoirement
    de la classe {@link org.geotools.renderer.j2d.RenderedLayer}. Quand le système
    a déterminé qu'il faut redessiner une couche, il appelle automatiquement
    la méthode <CODE>paint(...)</CODE> de celle-ci. Aux méthodes <CODE>paint(...)</CODE>
    de chacune des couches, le système transmet un même objet {@link java.awt.Graphics2D}
    temporaire qu'il aura préalablement créé et configuré comme suit:</P>

    <P ALIGN="center">
    <TABLE BORDER =1 cellpadding=4>
      <TR>
        <TD ALIGN="right" bgcolor=bisque><strong>Origine&nbsp;(0,0)&nbsp;des&nbsp;axes:</strong></TD>
        <TD bgcolor=lightgoldenrodyellow>Dépend de la projection cartographique
            en cours. Souvent en dehors de la région visible de la carte.</TD>
      </TR>
      <TR>
        <TD ALIGN="right" bgcolor=bisque><strong>Direction&nbsp;des&nbsp;axes:</strong></TD>
        <TD bgcolor=lightgoldenrodyellow>Les <var>x</var> croissent vers la droite
            et les <var>y</var> vers le <strong><U>haut</U></strong>, comme en géométrie.</TD>
      </TR>
      <TR>
        <TD ALIGN="right" bgcolor=bisque><strong>Unités&nbsp;des&nbsp;axes:</strong></TD>
        <TD bgcolor=lightgoldenrodyellow>Habituellement en mètres sur le terrain (et
            non en mètres sur l'écran!), on en degrés de longitude/latitude.</TD>
      </TR>
      <TR>
        <TD ALIGN="right" bgcolor=bisque><strong>Épaisseur&nbsp;des&nbsp;lignes:</strong></TD>
        <TD bgcolor=lightgoldenrodyellow>Dépend de la résolution de la carte.
            Peut être de l'ordre de 50 mètres par exemple.</TD>
      </TR>
    </TABLE>
    <br><b>Tableau 2: Configuration de {@link java.awt.Graphics2D} lors du traçage
           des couches d'une carte</b></P>

    <P ALIGN="justify">Cette configuration convient très bien au traçage de couches
    cartographiques. Elle permet de travailler avec les dimensions réelles des constructions
    sans se soucier du facteur d'échelle. Toutefois, elle ne convient pas du tout à l'écriture
    de texte. Par exemple, un texte de 12 unités de haut sera interprété comme ayant une
    hauteur de 12 mètres. Pour une carte d'échelle 1:50&nbsp;000, des lettres de 12 mètres
    apparaîtront à l'écran comme un point de dimension infime. Le programmeur peut
    changer temporairement la configuration de {@link java.awt.Graphics2D} (par exemple
    pour écrire du texte), mais doit le remettre dans son état initial (tableau 2)
    lorsqu'il aura terminé.</P>

    <p>&nbsp;</p><a name="transform"><table width="100%" bgcolor=burlywood cellpadding=6>
    <tr><td><font size=4><strong>Rappel de quelques notions sur les transformations affines</strong></font></td></tr></table>

    <P align="justify">Pour convertir en pixels des coordonnées exprimées selon un système
    d'unités quelconque, <I>Java2D</I> utilise une transformation affine représentée par
    la classe {@link java.awt.geom.AffineTransform}. En gros, une transformation affine
    est une matrice 3&times;3. En plaçant dans cette matrice les bons coefficients, on
    peut obtenir n'importe quelles combinaisons d'échelles, translations, rotations et
    cisaillements. Dans notre cas particulier, nous utilisons cette matrice pour
    convertir en pixels des coordonnées exprimées en mètres.</P>

    <P ALIGN="center"><IMG src="doc-files/AffineTransform.png"></P>

    <P align=justify>La classe {@link java.awt.geom.AffineTransform} fournit un ensemble de
    méthodes permettant d'appliquer des transformations sur cette matrice sans nécessairement
    connaître les mathématiques sous-jacentes. Par exemple la méthode <CODE>rotate(...)</CODE>
    modifiera les termes de la matrice 3&times;3 pour y ajouter l'effet d'une rotation d'un
    angle quelconque. Notons au passage une identité qui se révèlent parfois pratique:</P>

    <P ALIGN="center"><IMG src="doc-files/scaleX0.png"> et
                      <IMG src="doc-files/scaleY0.png"> sont invariants sous rotations.</P>

    <P align=justify>En l'absence de rotation ou de cisaillement, les termes
    <var>m</var><SUB>01</SUB> et <var>m</var><SUB>10</SUB> sont nuls. Restent
    alors les termes <var>m</var><SUB>00</SUB> et <var>m</var><SUB>11</SUB>,
    qui nous indiquent l'échelle de la carte telle qu'appliquée par la transformation
    affine. Dans cette situation simplifiée on obtient donc les relations suivantes:</P>

    <P ALIGN="center"><IMG src="doc-files/scaleX0.png">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>m</var><SUB>00</SUB>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE>AffineTransform.getScaleX()</CODE></P>
    <P ALIGN="center"><IMG src="doc-files/scaleY0.png">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>m</var><SUB>11</SUB>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE>AffineTransform.getScaleY()</CODE></P>

  </BODY>
</HTML>
