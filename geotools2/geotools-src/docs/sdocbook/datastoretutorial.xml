<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article>
  <title>Writing a DataStore</title>

  <sect1>
    <title>Introduction</title>

    <para>The GeoTools project strives to support as many geographical data
    formats as possible because getting data into the GeoTools API allows
    access to a vast suite of tools. In order to transform a data format into
    the GeoTools feature representation one must write an implementation of
    the DataStore interface.</para>

    <para>Once a DataSource implementation is written, any data written in
    that format becomes available not only for GeoTools users, but also for
    projects built on top of GeoTools. </para>

    <para>Writing a new DataSource for GeoTools is one of the best ways to get
    involved in the project, as writing it will make clear many of the core
    concepts of the API. Finally, the modular nature of GeoTools allows new
    DataStores to quickly become part of the next release, so that new formats
    are quickly available to all GeoTools users.</para>

    <para>The DataSource interface borrows most of its concepts and some of
    its syntax from the OpenGIS Consortium (OGC) <link linkend="???">Web
    Feature Service Specification</link>:</para>

    <itemizedlist>
      <listitem>
        <para>Feature - atomic unit of geographic information</para>
      </listitem>

      <listitem>
        <para>FeatureType - keepes track of what attributes each Feature can
        hold</para>
      </listitem>

      <listitem>
        <para>FeatureID - a unique id associated with each Feature (must start
        with a non-numeric character)</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>DataStore Implementation</title>

    <para>In this we will build a simple a simple property file based
    DataStore.</para>

    <para>(If you want to follow a long with this tutoiral, start a new java
    project in your favourate IDE, and ensure that geotools2 is on you
    classpath)</para>

    <para>We will be working with content in the following format:</para>

    <screen>_=id:Integer,geom:Geometry,name:String
rd1=1|wkt|road one
rd2=2|wkt|road two</screen>

    <sect2>
      <title>Extending AbstractDataStore</title>

      <para>To implement a DataStore you should subclass AbstractDataStore and
      provide the following methods:</para>

      <itemizedlist>
        <listitem>
          <para>getTypeNames()</para>
        </listitem>

        <listitem>
          <para>getSchema( typeName )</para>
        </listitem>

        <listitem>
          <para>getFeatureReader( typeName )</para>
        </listitem>

        <listitem>
          <para>getFeatureWriter( typeName )</para>
        </listitem>
      </itemizedlist>

      <para>Once these methods are implemented AbstractDataStore provides:</para>

      <itemizedlist>
        <listitem>
          <para>High-Level opperations -add, modify, remove,
          FeatureCollection, count, bounds</para>
        </listitem>

        <listitem>
          <para>Transactions</para>
        </listitem>

        <listitem>
          <para>Locking</para>
        </listitem>
      </itemizedlist>

      <para>Create the file SimpleDataStore as follows:</para>

      <programlisting>package org.geotools.data.tutorial;

import java.io.IOException;

import java.io.*;
import org.geotools.data.*;
import org.geotools.feature.*;

public class SimpleDataStore extends AbstractDataStore {

}</programlisting>
    </sect2>

    <sect2>
      <title>DataStore - getTypeNames()</title>

      <para>A single DataStore may provide access to several different kinds
      of information. This method provides a list of the available types.</para>

      <para>For our purposes this will be the name of the property files in a
      directory.</para>

      <para>Add getTypeNames():</para>

      <programlisting>String path = &#34;.&#34;;
public String[] getTypeNames() {
    File dir = new File( path );
    FilenameFilter f;
    String list[] = dir.list( new FilenameFilter(){
        public boolean accept(File dir, String name) {
            return name.endsWith(&#34;.properties&#34;);
        }
    });
    for( int i=0; i&#60;list.length;i++){
        list[i] = list[i].substring(0, list[i].lastIndexOf(&#39;.&#39;));
    }
    return list;
}</programlisting>
    </sect2>

    <sect2>
      <title>DataStore - getSchema( typeName )</title>

      <para>Schema information is provided by the FeatureType class. This
      method provides access to a FeatureType referenced by a type name.</para>

      <para>To implement this method we will need to do two things, read a
      line from a properties file, and interpret the line as a FeatureType.</para>

      <para>The DataUtilities class provides an assortment of helper
      functions. In this method we will use DataUtilities.createType( name,
      spec ).</para>

      <para>Add getSchema( typeName ):</para>

      <programlisting>public FeatureType getSchema(String typeName) throws IOException {
    String typeSpec = property( typeName, &#34;_&#34;);
    System.out.println( typeSpec );
    try {
        return DataUtilities.createType( typeName,typeSpec );
    } catch (SchemaException e) {
        e.printStackTrace();
        throw new DataSourceException( typeName+&#34; schema not available&#34;, e);
    }
}</programlisting>

      <para>Add property( typeName, key ):</para>

      <programlisting>private String property( String typeName, String key ) throws IOException {
    File file = new File( path, typeName+&#34;.properties&#34;);
    BufferedReader reader = new BufferedReader( new FileReader( file ) );        
    for( String line = reader.readLine(); line != null; line = reader.readLine()){
        if( line.startsWith( key+&#34;=&#34; )){
            return line.substring( key.length()+1 );
        }
    }
    return null;        
}</programlisting>
    </sect2>

    <sect2>
      <title>AbstractDataStore - GetFeatureReader( typeName )</title>

      <para>FeatureReader is the low-level api provided by DataStore for
      accessing Feature content. This method provides access to a content of a
      DataStore. This method is not part of the DataStore api.</para>

      <para>FeatureReader is similar to the Java Iterator construct, with the
      addition of FetureType (and IOExceptions).</para>

      <para>FeatureReader interface:</para>

      <itemizedlist>
        <listitem>
          <para>getFeatureType()</para>
        </listitem>

        <listitem>
          <para>next()</para>
        </listitem>

        <listitem>
          <para>hasNext()</para>
        </listitem>

        <listitem>
          <para>close()</para>
        </listitem>
      </itemizedlist>

      <para>Add getFeatureReader( typeName ):</para>

      <programlisting>protected FeatureReader getFeatureReader(String typeName) throws IOException {
    return new PropertiesFeatureReader( path, typeName );        
}</programlisting>

      <para>To implement our FeatureReader, we will need to do several things:
      open a File, read through it line by line parsing Features as we go.</para>

      <para>Create the file PropertyFeatureReader as follows:</para>

      <programlisting>package org.geotools.data.tutorial;

import java.io.*;
import java.util.NoSuchElementException;

import org.geotools.data.*;
import org.geotools.feature.*;

public class PropertiesFeatureReader implements FeatureReader {
    BufferedReader reader;
    FeatureType type;
    String line;
    
    public PropertiesFeatureReader( String path, String typeName ) throws IOException {
        File file = new File( path, typeName+&#34;.properties&#34;);
        reader = new BufferedReader( new FileReader( file ) );        
        line = reader.readLine();                        
        if( line.startsWith(&#34;_=&#34;)){
            try {
                type = DataUtilities.createType( typeName, line.substring(2));
            } catch (SchemaException e) {
                throw new DataSourceException( typeName+&#34; schema not available&#34;, e );
            }
        }
        line = null;        
    }C
}
</programlisting>

      <para>We will then implement the methods required for FeatureReader.</para>

      <programlisting>public FeatureType getFeatureType() {
    return type;
}
public Feature next()
    throws IOException, IllegalAttributeException, NoSuchElementException {
    if(!hasNext()){
        throw new NoSuchElementException();
    }
    int split = line.indexOf(&#39;=&#39;);
    String fid = line.substring( 0, split );
    String text[] = line.substring( split+1 ).split(&#34;|&#34;);
                
    return DataUtilities.parse( type, fid, text );        
}
public boolean hasNext() throws IOException {
    if( line != null){
        return true;
    }
    line = reader.readLine();
    return line != null;
}
public void close() throws IOException {
    reader.close();
    reader = null;
    line = null;
}
</programlisting>
    </sect2>

    <sect2>
      <title>AbstractDataStore - getFeatureWriter( typeName )</title>

      <para>FeatureWriter is the low-level api storing Feature content. This
      method is not part of the DataStore api.</para>

      <para>FeatureWriter:</para>

      <itemizedlist>
        <listitem>
          <para>getFeatureType</para>
        </listitem>

        <listitem>
          <para>hasNext</para>
        </listitem>

        <listitem>
          <para>next</para>
        </listitem>

        <listitem>
          <para>write</para>
        </listitem>

        <listitem>
          <para>remove</para>
        </listitem>

        <listitem>
          <para>close</para>
        </listitem>
      </itemizedlist>

      <para>Add getFeatureWriter( typeName ):</para>

      <programlisting>protected FeatureWriter getFeatureWriter(String typeName) throws IOException {
    return new PropertiesFeatureWriter( path, typeName );
}</programlisting>

      <para>Create the file ProperiesFeatureWriter( path, typeName ):</para>

      <programlisting>to be added</programlisting>

      <para>FeatureWriter is less intuitive then FeatureReader in that it does
      not follow the example of Iterator as closely.</para>
    </sect2>

    <sect2>
      <title>DataStore - createSchema( featureType)</title>

      <para>This method provides the ability to create new FeatureType. For
      our DataStore we will use this to create new properties files.</para>

      <para>To implement this method we will once again make use of the
      DataUtilities class.</para>

      <para>Add createSchmea( featureType ):</para>

      <programlisting>public void createSchema(FeatureType featureType) throws IOException {
    String typeName = featureType.getTypeName();
    File file = new File( path, typeName+&#34;.properties&#34;);
    BufferedWriter writer = new BufferedWriter( new FileWriter( file ) );
    writer.write(&#34;_=&#34;);
    writer.write( DataUtilities.spec( featureType ) );
    writer.close();
} </programlisting>
    </sect2>
  </sect1>

  <sect1>
    <title>Using a DataStore</title>

    <para>Now that we have implemented a simple DataStore we can explore some
    of the capabilites made available to us.</para>

    <para>The most obvious place to start is to work through the contents of a
    simple properties file:</para>

    <screen>_=id:Integer,geom:Geometry,name:String
fid1=</screen>

    <para></para>

    <sect2>
      <title>DataStore.getFeatureReader( featureType, filter, transaction )</title>

      <para>We are going to start, as you may imagine, by using the DataStore
      api to aquire a FeatureReader. This may be more complicated then you
      expected, we certaintly did not talk about Filters or Transactions when
      we implemented our PropertiesDataStore.</para>

      <para>Parameters:</para>

      <itemizedlist>
        <listitem>
          <para>FeatureType is used to encapsulate the attributes, namespace,
          and typeName requested from the DataStore. While you may use
          DataStore.getSchema( typeName ) to retrive the types as specified by
          the DataStore, you may also create your own FeatureType to limit the
          attributes returned or cast the result into a specific namespace.</para>
        </listitem>

        <listitem>
          <para>Filter is used to define constraints on which features should
          be fetched. The constraints can be on spatial and non-spatial
          attributes of the features.</para>
        </listitem>

        <listitem>
          <para>Transaction allows access the contents of a DataStore during
          modification.</para>
        </listitem>
      </itemizedlist>

      <para>Example use:</para>

      <programlisting>FeatureType type = datastore.getSchema( &#34;road&#34; );
FeatureReader reader = datastore.getFeatureReader( type, Filter.NONE, Transaction.AUTO_COMMIT );
try {
    while( reader.hasNext() ){
        System.out.println( reader.next() );
    }
} finally {
    reader.close();
}</programlisting>
    </sect2>

    <sect2>
      <title>DataStore.getFeatureSource( typeName )</title>

      <para>This method is the gateway to our high-level as provided by an
      instance of FetureSource, FeatureStore or FeatureLocking. The returned
      instance represents the contents of a single named FeatureType provided
      by the DataStore. The type of the returned instance indicates the
      capabilities available.</para>

      <sect3>
        <title>FeatureSource</title>

        <para>FeatureSource is the start of a high-level api. FeatureSource
        provides the ability to query a DataStore and represents the contents
        of a single FeatureType. In our example the PropertiesDataStore
        represented a directory full of properties files, FeatureSource will
        represent a single one of those files.</para>

        <para>Example:</para>

        <programlisting>FeatureSource road = datastore.getFeatureSource( &#34;road&#34; );</programlisting>

        <para>FeatureSource defines:</para>

        <itemizedlist>
          <listitem>
            <para>getFeatures( query ) - request features specified by query</para>
          </listitem>

          <listitem>
            <para>getFeatures( filter ) - request features based on
            constraints</para>
          </listitem>

          <listitem>
            <para>getFeatures() - request all features</para>
          </listitem>

          <listitem>
            <para>getSchema() - aquire FeatureType</para>
          </listitem>

          <listitem>
            <para>getBounds - return the bounding box of all features</para>
          </listitem>

          <listitem>
            <para>getBounds( query ) - request bounding box of specified
            features</para>
          </listitem>

          <listitem>
            <para>getCount( query ) - request number of features specified by
            query</para>
          </listitem>
        </itemizedlist>

        <para>FeatureSource also defines an event notification system and
        provides access to the DataStore which created it. You may have more
        then one FeatureSource opperating against a file at any time.</para>

        <para>The Query class is used to encapsulate the request information.</para>

        <itemizedlist>
          <listitem>
            <para>Filter - used to define constraints on which features should
            be fetched. The constraints can be on spatial and non-spatial
            attributes of the features.</para>
          </listitem>

          <listitem>
            <para>Handle - a name given to the query, should be used in error
            reporting so users can figure out where they went wrong.</para>
          </listitem>

          <listitem>
            <para>MaxFeatures - used to limit the number of features returned
            in the request.</para>
          </listitem>

          <listitem>
            <para>PropertyNames - used to request features with abbreviated
            attribute sets</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3>
        <title>FeatureResults</title>

        <para>While the FeatureSource api does allow you to represent a named
        FeatureType, it still does not allow direct access to a FeatureReader.
        The getFeatures methods actually return an instance of FeatureResults.</para>

        <para>FeatureResults defines:</para>

        <itemizedlist>
          <listitem>
            <para>reader() - access to a FeatureReader</para>
          </listitem>

          <listitem>
            <para>getBounds() - bounding box of features</para>
          </listitem>

          <listitem>
            <para>getCount() - number of features</para>
          </listitem>

          <listitem>
            <para>collection() - an in memory collection of features</para>
          </listitem>
        </itemizedlist>

        <para>FeatureResults is the closest thing we have to a prepaired
        request. Many DataStores are able to provide optimized implementations
        of these requests natively.</para>

        <para>Example:</para>

        <programlisting>FeatureSource road = datastore.getFeatureSource( &#34;road&#34; );
FeatureResults features = road.getFeatures();
FeatureReader reader = features.reader();
try {
    while( reader.hasNext() ){
        System.out.println( reader.next() );
    }
} finally {
    reader.close();
}
System.out.println(&#34;count:&#34;+road.count(Query.ALL) );
System.out.println(&#34;bounds:&#34;+road.getBounds(Query.ALL);
System.out.println(&#34;count:&#34;+features.count() );
System.out.println(&#34;count:&#34;+features.getBounds() );</programlisting>

        <para>In the above example road.count(Query.ALL) may return -1,
        indicating that the value is expensive for the DataStore to calculate.
        features.count() will always produce an answer.</para>

        <para>Care should be taken when using the collection() method to
        capture the contents of a DataStore in memory. GIS applications often
        produces large volumnes of information and can place a stree on memory
        use.</para>
      </sect3>

      <sect3>
        <title>FeatureStore</title>

        <para>FeatureStore continues our high-level api by providing
        Transaction support and modification opperations. FeatureStore is an
        extension of FeatureSource, you may check the result of
        getFeatureSource( typeName ) with the instanceof opperator.</para>

        <para>Example:</para>

        <programlisting>FeatureSource source = datastore.getFeatureSource( &#34;road&#34; );
if(!source instanceof FeatureStore){
    throw Exception(&#34;Modification not supported&#34;);
}
FeatureStore road = (FeatureStore) source;</programlisting>

        <para>FeatureStore defines:</para>

        <itemizedlist>
          <listitem>
            <para>addFeatures( featureReader)</para>
          </listitem>

          <listitem>
            <para>removeFeatures( filter )</para>
          </listitem>

          <listitem>
            <para>modifyFeatures( type, value, filter )</para>
          </listitem>

          <listitem>
            <para>modifyFeatures( types, values, filter )</para>
          </listitem>

          <listitem>
            <para>setFeatures( featureReader )</para>
          </listitem>

          <listitem>
            <para>setTransaction( transaction )</para>
          </listitem>
        </itemizedlist>

        <para>Once again many DataStores are able to provide optimized
        implementations of these opperations.</para>
      </sect3>

      <sect3>
        <title>FeatureLocking</title>

        <para>FeatureLocking is the last extension to our high-level api. It
        provides support for preventing modifications to features for the
        duration of a Transaction, or a period of time.</para>

        <para>FeatureLocking defines:</para>

        <itemizedlist>
          <listitem>
            <para>setFeatureLock( featureLock )</para>
          </listitem>

          <listitem>
            <para>lockFeatures( query ) - lock features specified by query</para>
          </listitem>

          <listitem>
            <para>lockFeatures( filter ) - lock according to constraints</para>
          </listitem>

          <listitem>
            <para>lockFeatures() - lock all </para>
          </listitem>

          <listitem>
            <para>unLockFeatures( query )</para>
          </listitem>

          <listitem>
            <para>unLockFeatures( filter )</para>
          </listitem>

          <listitem>
            <para>unLockFeatures()</para>
          </listitem>

          <listitem>
            <para>releaseLock( string )</para>
          </listitem>

          <listitem>
            <para>refreshLock( string )</para>
          </listitem>
        </itemizedlist>

        <para>The concept of a FeatureLock matches the description provided in
        the OFC Web Feature Server Specification. Locked Features can only be
        used via Transactions that have been provided with the correct
        authroization.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>DataStore.getFeatureWriter( typeName, filter, transaction )</title>

      <para>Creates a FeatureWriter used to modify features indicated by a
      constraint.</para>

      <para>Example - removing all features:</para>

      <programlisting>FeatureWriter writer =
    store.getFeatureWriter( &#34;road&#34;, Filter.NONE, Transaction.AUTO_COMMIT  );

Feature feature;

try {
    while (writer.hasNext()) {
        feature = writer.next();
        writer.remove();
    }
} finally {
    writer.close();
}</programlisting>

      <para>This FeatureWriter does not allow the addition of new content, it
      can be used for modification and removal only.</para>

      <para>DataStores can often provide an optimized implementation.</para>
    </sect2>

    <sect2>
      <title>DataStore.getFeatureWriter( typeName, transaction )</title>

      <para>Creates a general purpose FeatureWriter. New content may be added
      after iterating through the provided content.</para>

      <para>Example - completely all features:</para>

      <programlisting>FeatureType type = store.getSchema(&#34;replace&#34;);
FeatureReader reader;
FeatureWriter writer;
Feature feature, newFeature;

reader = store.getFeatureReader(type, Filter.NONE, Transaction.AUTO_COMMIT );
writer = store.getFeatureWriter(&#34;road&#34;, Transaction.AUTO_COMMIT );
try {
    while (writer.hasNext()) {
        feature = writer.next();
        writer.remove();
    }
    while (reader.hasNext()) {
        feature = reader.next();
        newFeature = writer.next();
        newFeature.setAttributes(feature.getAttributes(null));
        writer.write();
    }
} finally {
    reader.close();
    writer.close();
}</programlisting>
    </sect2>

    <sect2>
      <title>DataStore.getFeatureWriterAppend( typeName, transaction )</title>

      <para>Creates a FeatureWriter for additing content.</para>

      <para>Example - making a copy</para>

      <programlisting>FeatureReader reader;
FeatureWriter writer;
Feature feature, newFeature;

FeatureType type = getSchema( &#34;road&#34; );
FeatureType type2 = DataUtilities( &#34;copy&#34;, &#34;id:Integer,geom:Geometry,name:String&#34; );

reader = store.getFeatureReader(type, Filter.NONE, Transaction.AUTO_COMMIT );
store.createSchema( copy );
writer = store.getFeatureWriterAppend( &#34;copy&#34;, Transaction.AUTO_COMMIT );
try {
    while (reader.hasNext()) {
        feature = reader.next();
        newFeature = writer.next();
        newFeature.setAttributes(feature.getAttributes(null));
        writer.write();
    }
}
finally {
    reader.close();
    writer.close();
}</programlisting>

      <para>DataStores can often provide an optimized implementation.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>DataStore Factory Implementation</title>

    <para>To make your DataStore truly independent and pluggable, your must
    create a class implementing the DataStoreFactorySpi interface.</para>

    <para>This allows the Service Provider Interface mechanism to dynamically
    plug in your new DataStrore with no implementation knowledge. Code that
    uses the DataStoreFinder can just add the new DataStore to the classpath
    and it will work!</para>

    <para>This code operates by looking at the services file:
    META-INF/services/org.GeoTools.data.DataStoreFactorySpi. This file
    requires the fillname of the factory that implements the DataStoreSpi
    interface.</para>

    <para>Example org.GeotTools.data.DataStoreFactorySpi file:</para>

    <screen>org.GeoTools.data.tutorial.PropertiesDataStoreFactory</screen>

    <para>The DataStoreFactorySpi provides information on the Parameters
    required for construction, DataStoreFactoryFinder provides the ability to
    create DataStores representing existing information, and the ability to
    create new physical storage.</para>
  </sect1>

  <sect1>
    <title>Issues with DataStore developement</title>

    <para>AbstractDataStore provides a lot of functionality based on the five
    methods you provided earlier. By examining its implementation we have an
    oppertunity to discuss several issues with DataStore developement. Please
    keep these issues in mind when optimizing your own DataStore.</para>

    <para>In general the GOF decorator pattern is used to layer functionality
    around the FeatureReader and FeatureWriters you provided. This is very
    similar to the design of the java io library.</para>

    <para>From AbstractDataStore getFeatureReader( featureType, filter,
    transaction ):</para>

    <programlisting>public FeatureReader getFeatureReader(FeatureType featureType,
        Filter filter, Transaction transaction) throws IOException {
    if (filter == Filter.ALL) {
        return new EmptyFeatureReader(featureType);
    }
    String typeName = featureType.getTypeName();
    FeatureReader reader = getFeatureReader(typeName);
    if (filter != Filter.NONE) {
        reader = new FilteringFeatureReader(reader, filter);
    }
    if (transaction != Transaction.AUTO_COMMIT) {
        Map diff = state(transaction).diff(typeName);
        reader = new DiffFeatureReader(reader, diff);
    }
    if (!featureType.equals(reader.getFeatureType())) {
        reader = new ReTypeFeatureReader(reader, featureType);
    }
    return reader;
}</programlisting>

    <para>To start if everything is to be filtered out, an EmptyFeatureReader
    is returned of the correct FeatureType.</para>

    <para>We then begin the process of layering functionality on top of the
    basic FeatureReader.</para>

    <para>If the provided filter was not Filter.NONE the
    FilteringFeatureReader is used as a wrapper. FilteringFeatureReader peeks
    ahead when hasNext() is called, saving the &#34;next&#34; found feature.</para>

    <para>If a transaction is being used, an instance of TransactionStateDiff
    is used to record a difference Map based on typeName. DiffFeatureReader is
    used as a wrapper, allowing the contents of your reader to be checked for
    removal, or modification before being provided to the user. Any additions
    performed against the Transaction are also returned.</para>

    <para>Finally if the requested FeatureType differs from the one provided a
    ReTypeFeatureReader is used to change the Schema on the fly.</para>

    <para>From AbstractDataStore getFeatureWriter( typeName, filter,
    transaction):</para>

    <programlisting>public FeatureWriter getFeatureWriter(String typeName, Filter filter,
        Transaction transaction) throws IOException {
    if (filter == Filter.ALL) {
        FeatureType featureType = getSchema(typeName);
        return new EmptyFeatureWriter(featureType);
    }
    FeatureWriter writer;

    if (transaction == Transaction.AUTO_COMMIT) {
        writer = getFeatureWriter(typeName);
    } else {
        writer = state(transaction).writer(typeName);
    }
    if (lockingManager != null) {
        writer = lockingManager.checkedWriter(writer, transaction);
    }
    if (filter != Filter.NONE) {
        writer = new FilteringFeatureWriter(writer, filter);
    }
    return writer;
}</programlisting>

    <para>Once again Filter all is singled out for optimization, an
    EmptyFeatureWriter of the correct type is returned.</para>

    <para>TransactionStateDiff is once again to help with implementing
    transaction support. The writer method will construct a FeatureWriter
    wrapped around a FeatureReader from your DataStore. Any modifications are
    stored in the a difference Map.</para>

    <para>This time around we also need to worry about FeatureLocking support,
    the InProcessLockingManger provides a wrapper that will prevent any
    modifications taking place with out proper authroization.</para>

    <para>Finally a FilteringFeatureWriter is used, if required, to skip over
    any Features not meeting the constraints.</para>
  </sect1>
</article>