<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <TITLE>package org.geotools.io.image</TITLE>
  </HEAD>
  <BODY>
    Extensions to {@link javax.imageio.ImageReader}
    for binary and ASCII files.

    Image I/O extensions are provided as part of
    <A HREF="../../gc/package-summary.html">Grid Coverage implementation</A>.
    The <CODE>geotools-gcs.jar</CODE> file declares a service provider for the
    following image readers:</P>

    <TABLE ALIGN="center" BORDER='3' CELLPADDING='6' BGCOLOR="F4F8FF">
      <TR BGCOLOR="#B9DCFF">
        <TH>{@link javax.imageio.ImageReader} subclass</TH>
        <TH>Name</TH>
        <TH>MIME type</TH>
      </TR>
      <TR>
        <TD>{@link org.geotools.io.image.RawBinaryImageReader}</TD>
        <TD>raw</TD>
        <TD>image/raw</TD>
      </TR>
      <TR>
        <TD>{@link org.geotools.io.image.TextMatrixImageReader}</TD>
        <TD>matrix</TD>
        <TD>text/matrix</TD>
      </TR>
      <TR>
        <TD>{@link org.geotools.io.image.TextRecordImageReader}</TD>
        <TD>gridded records</TD>
        <TD>text/x-grid</TD>
      </TR>
    </TABLE>

    <P ALIGN="justify">{@link org.geotools.io.image.SimpleImageReader} is
    the base class for image decoders reading stream with few (if any)
    meta-data. Examples of such streams are matrix containing the pixels
    values in a binary form (RAW images), or ASCII files containing values
    written as decimal numbers. Such kinds of stream are not uncommon in the
    remote sensing field. They often contain geophysical values (e.g.
    temperature in Celsius degrees, elevation in metres, etc.) better
    represented as floating point numbers than integers. For example,
    a user may want to read an ASCII file containing gridded elevation
    on the ocean floor (left side below). {@link org.geotools.io.image.TextRecordImageReader}
    can read such file, detect automatically minimum and maximum values (in order
    to scale the grayscale palette) and produce the image below:</P>

    <P ALIGN="justify"></P>
    <TABLE ALIGN="center" CELLPADDING='24'>
      <TR>
        <TD><PRE>
Longitude Latitude Altitude
59.9000   -30.0000   -3022
59.9333   -30.0000   -3194
59.9667   -30.0000   -3888
60.0000   -30.0000   -3888
45.0000   -29.9667   -2502
45.0333   -29.9667   -2502
45.0667   -29.9667   -2576
45.1000   -29.9667   -2576
45.1333   -29.9667   -2624
45.1667   -29.9667   -2690
45.2000   -29.9667   -2690
45.2333   -29.9667   -2692
45.2667   -29.9667   -2606
45.3000   -29.9667   -2606
45.3333   -29.9667   -2528
</PRE>etc...</TD>
        <TD>
          <IMG SRC="doc-files/Sandwell.jpeg">
        </TD>
      </TR>
    </TABLE>

    <P ALIGN="justify">By default, {@link org.geotools.io.image.SimpleImageReader}
    store decoded image using data type {@link java.awt.image.DataBuffer#TYPE_FLOAT}
    and a grayscale color space. This politic produce image matching closely the
    original data, i.e. it involves as few transformations as possible. But
    displaying floating-point image is usually very slow. User are strongly
    encourages to use <A HREF="http://java.sun.com/products/java-media/jai/">Java
    Advanced Imaging</A>'s operations after reading in order to scale data as
    they see fit. The example below reformat the {@link java.awt.image.DataBuffer#TYPE_FLOAT}
    data into {@link java.awt.image.DataBuffer#TYPE_BYTE} and change the grayscale
    colors to an indexed color model.</P>

    <P>&nbsp;</P>

<TABLE align="center" bgcolor="#F8F8F8" border="3" cellpadding="12"><TR><TD nowrap>
<PRE><FONT color="#0000A0">
import {@link javax.media.jai.JAI javax.media.jai.JAI};
import {@link javax.media.jai.ImageLayout javax.media.jai.ImageLayout};
import {@link java.awt.RenderingHints java.awt.RenderingHints};
import {@link java.awt.image.DataBuffer java.awt.image.DataBuffer};
import {@link java.awt.image.IndexColorModel java.awt.image.IndexColorModel};
import {@link java.awt.image.renderable.ParameterBlock java.awt.image.renderable.ParameterBlock};

<I><FONT color="#008000">// Omitting class and method declaration...</FONT></I>

<FONT color="#808080"><STRONG>
/*
 * Prepare the indexed color model. Arrays
 * R, G and B should contains 256 RGB values.
 */</STRONG></FONT>
final byte[] R=...
final byte[] G=...
final byte[] B=...
final IndexColorModel colors = new IndexColorModel(8, 256, R,G,B);
final ImageLayout     layout = new ImageLayout().setColorModel(colorModel);
final RenderingHints   hints = new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout);
<FONT color="#808080"><STRONG>
/*
 * Rescale the image.   First, all pixels values are transformed using
 * the equation pi=CO+C1*p. Then, type float is clamp to type byte and
 * the new index color model is set.   Displaying such an image should
 * be much faster.
 */</STRONG></FONT>
final double C0 = ...
final double C1 = ...
image = JAI.create("Rescale", new ParameterBlock().addSource(image).add(new double[]{C1}).add(new double[]{C0}));
image = JAI.create("Format",  new ParameterBlock().addSource(image).add(DataBuffer.TYPE_BYTE), hints);
</FONT></PRE></TD></TR></TABLE>

  </BODY>
</HTML>
