<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article>
  <title>DataStore Tutorial 2: Use</title>

  <para>In this document we abilities of the PropertyDataStore implemented in
  DataStore Tutorial 1: Implementation.</para>

  <sect1>
    <title>DataStore Documents</title>

    <para>In this series of documents we will build a simple a simple java
    property file based DataStore, and in the process explore several aspects
    of DataStores and their implementation.</para>

    <para>DataStore Documents:</para>

    <orderedlist>
      <listitem>
        <para>DataStore Tutorial 1: Implementation</para>
      </listitem>

      <listitem>
        <para>DataStore Tutorial 2: Use</para>
      </listitem>

      <listitem>
        <para>DataStore Tutorial 3: Extension</para>
      </listitem>

      <listitem>
        <para>DataStore Tutorial 4: Capabilities</para>
      </listitem>

      <listitem>
        <para>DataStore Tutorial 5: Optimization</para>
      </listitem>
    </orderedlist>
  </sect1>

  <sect1>
    <title>DataStore API</title>

    <para>Now that we have implemented a simple DataStore we can explore some
    of the capabilites made available to us.</para>

    <para>The example we use will work against the file <filename>road.properties</filename>:</para>

    <screen>_=id:Integer,name:String
fid1=1|jody
fid2=2|brent
fid3=3|dave
fid4=4|justin</screen>

    <para>PropertyDataStore API for data access:</para>

    <itemizedlist>
      <listitem>
        <para>getTypeNames()</para>
      </listitem>

      <listitem>
        <para>getSchema( typeName )</para>
      </listitem>

      <listitem>
        <para>getFeatureReader( featureType, filter, transaction )</para>
      </listitem>

      <listitem>
        <para>getFeatureSource( typeName )</para>
      </listitem>
    </itemizedlist>

    <para>If you would like to follow along with these examples they are
    available as a JUnit Test along with the source code for
    PropertyDataStore.</para>

    <sect2>
      <title>getTypeNames()</title>

      <para>The method getTypeNames provides a list of the available types.</para>

      <para>getTypeNames() example:</para>

      <programlisting>PropertyDataStore store = new PropertyDataStore( new File(&#34;.&#34;) );
String names[] = store.getTypeNames();
System.out.println( names.length ); // 1
System.out.println( names[0] );     // road</programlisting>
    </sect2>

    <sect2>
      <title>getSchema( typeName )</title>

      <para>The method getSchema( typeName ) provides access to a FeatureType
      referenced by a type name.</para>

      <para>getSchema( typeName ) example:</para>

      <programlisting>PropertyDataStore store = new PropertyDataStore( new File(&#34;.&#34;) );
FeatureType type = store.getSchema( &#34;road&#34; );

System.out.println( type.getTypeName() );                      // road
System.out.println( type.getNameSpace() );                     // directory name of store
System.out.println( type.getAttributeCount() );                // 2

AttributeType id = type.getAttributeType(0);
System.out.println( id.getName() );                            // id
System.out.println( id.getType().toString() );                 // class java.lang.Integer

AttributeType name = type.getAttributeType(1);
System.out.println( name.getName() );                          // name
System.out.println( name.getType().toString() );               // class java.lang.String</programlisting>
    </sect2>

    <sect2>
      <title>getFeatureReader( featureType, filter, transaction )</title>

      <para>The method getFeatureReader( featureType, filter, transaction )
      allows access to the contents of our DataStore. The method signature may
      be more complicated expected, we certaintly did not talk about Filters
      or Transactions when we implemented our PropertyDataStore.</para>

      <para>Parameters:</para>

      <itemizedlist>
        <listitem>
          <para>FeatureType is used to encapsulate the attributes, namespace,
          and typeName requested from the DataStore. While you may use
          DataStore.getSchema( typeName ) to retrive the types as specified by
          the DataStore, you may also create your own FeatureType to limit the
          attributes returned or cast the result into a specific namespace.</para>
        </listitem>

        <listitem>
          <para>Filter is used to define constraints on which features should
          be fetched. The constraints can be on spatial and non-spatial
          attributes of the features.</para>
        </listitem>

        <listitem>
          <para>Transaction allows access the contents of a DataStore during
          modification.</para>
        </listitem>
      </itemizedlist>

      <para>getFeatureReader( featureType, filter, transaction ) example:</para>

      <programlisting>PropertyDataStore store = new PropertyDataStore( new File(&#34;.&#34;) );
FeatureType type = store.getSchema( &#34;road&#34; );
FeatureReader reader = datastore.getFeatureReader( type, Filter.NONE, Transaction.AUTO_COMMIT );
try {
    int count = 0;
    while( reader.hasNext() ){
        reader.next();
        count++;
    }
    System.out.println( count );             // 4
} finally {
    reader.close();
}</programlisting>

      <para>Example with a Simple Filter:</para>

      <programlisting>PropertyDataStore store = new PropertyDataStore( new File(&#34;.&#34;) );
FeatureType type = store.getSchema( &#34;road&#34; );

Filter filter = FilterFactory.createFilterFactory().createFidFilter(&#34;fid1&#34;);
FeatureReader reader = store.getFeatureReader( type, filter, Transaction.AUTO_COMMIT );

System.out.println( reader.next().getID() ); // fid1
System.out.println( reader.hasNext() ); // false
reader.close();</programlisting>

      <para>Example with a Transaction:</para>

      <programlisting>PropertyDataStore store = new PropertyDataStore( new File(&#34;.&#34;) );
FeatureType type = store.getSchema( &#34;road&#34; );
Transaction transaction = new DefaultTransaction();
FeatureReader reader = store.getFeatureReader( type, Filter.NONE, transaction );
List list = new ArrayList();
try {
    while( reader.hasNext() ){
        list.add( reader.next().getID() );
    }
}
finally {
    reader.close();
}
System.out.println( list ); // [fid1, fid2, fid3, fid4]</programlisting>
    </sect2>

    <sect2>
      <title>getFeatureSource( typeName )</title>

      <para>This method is the gateway to our high-level as provided by an
      instance of FeatureSource, FeatureStore or FeatureLocking. The returned
      instance represents the contents of a single named FeatureType provided
      by the DataStore. The type of the returned instance indicates the
      capabilities available.</para>

      <para>Our PropertyDataStore will only support the an instance of
      FeatureSource.</para>

      <para>Example getFeatureSource:</para>

      <programlisting>PropertyDataStore store = new PropertyDataStore( new File(&#34;.&#34;) );
FeatureSource road = store.getFeatureSource( &#34;road&#34; );</programlisting>

      <sect3>
        <title>FeatureSource</title>

        <para>FeatureSource provides the ability to query a DataStore and
        represents the contents of a single FeatureType. In our example the
        PropertiesDataStore represented a directory full of properties files,
        FeatureSource will represent a single one of those files.</para>

        <para>FeatureSource defines:</para>

        <itemizedlist>
          <listitem>
            <para>getFeatures( query ) - request features specified by query</para>
          </listitem>

          <listitem>
            <para>getFeatures( filter ) - request features based on
            constraints</para>
          </listitem>

          <listitem>
            <para>getFeatures() - request all features</para>
          </listitem>

          <listitem>
            <para>getSchema() - aquire FeatureType</para>
          </listitem>

          <listitem>
            <para>getBounds - return the bounding box of all features</para>
          </listitem>

          <listitem>
            <para>getBounds( query ) - request bounding box of specified
            features</para>
          </listitem>

          <listitem>
            <para>getCount( query ) - request number of features specified by
            query</para>
          </listitem>
        </itemizedlist>

        <para>FeatureSource also defines an event notification system and
        provides access to the DataStore which created it. You may have more
        then one FeatureSource opperating against a file at any time.</para>

        <para>The Query class is used to encapsulate the request information.</para>

        <itemizedlist>
          <listitem>
            <para>Filter - used to define constraints on which features should
            be fetched. The constraints can be on spatial and non-spatial
            attributes of the features.</para>
          </listitem>

          <listitem>
            <para>Handle - a name given to the query, should be used in error
            reporting so users can figure out where they went wrong.</para>
          </listitem>

          <listitem>
            <para>MaxFeatures - used to limit the number of features returned
            in the request.</para>
          </listitem>

          <listitem>
            <para>PropertyNames - used to request features with abbreviated
            attribute sets</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3>
        <title>FeatureResults</title>

        <para>While the FeatureSource api does allow you to represent a named
        FeatureType, it still does not allow direct access to a FeatureReader.
        The getFeatures methods actually return an instance of FeatureResults.</para>

        <para>FeatureResults defines:</para>

        <itemizedlist>
          <listitem>
            <para>reader() - access to a FeatureReader</para>
          </listitem>

          <listitem>
            <para>getBounds() - bounding box of features</para>
          </listitem>

          <listitem>
            <para>getCount() - number of features</para>
          </listitem>

          <listitem>
            <para>collection() - an in memory collection of features</para>
          </listitem>
        </itemizedlist>

        <para>FeatureResults is the closest thing we have to a prepaired
        request. Many DataStores are able to provide optimized implementations
        of these requests natively.</para>

        <para>FeatureResults Example:</para>

        <programlisting>PropertyDataStore store = new PropertyDataStore( new File(&#34;.&#34;) );
FeatureSource road = store.getFeatureSource( &#34;road&#34; );
FeatureResults features = road.getFeatures();
FeatureReader reader = features.reader();
List list = new ArrayList();
try {
    while( reader.hasNext() ){
    list.add( reader.next().getID() );                
    }
} finally {
    reader.close();
}
System.out.println( list );                               // [fid1, fid2, fid3, fid4]
System.out.println(&#34;count:&#34;+road.getCount(Query.ALL) );   // -1   (not optimized yet)
System.out.println(&#34;bounds:&#34;+road.getBounds(Query.ALL) ); // null (not optimized yet)
System.out.println(&#34;count:&#34;+features.getCount() );        // 4
System.out.println(&#34;count:&#34;+features.getBounds() );       // Env[-1.0 : 0.0, -1.0 : 0.0]
System.out.println( features.collection().size() );       // 4</programlisting>

        <para>In the above example road.count(Query.ALL) will return -1,
        indicating that the value is expensive for the DataStore to calculate,
        or at least that our PropertyDataStore implementation does not provide
        an implementation. Features.count() will always produce an answer.</para>

        <para>Care should be taken when using the collection() method to
        capture the contents of a DataStore in memory. GIS applications often
        produces large volumnes of information and can place a strain on
        memory use.</para>
      </sect3>
    </sect2>
  </sect1>
</article>