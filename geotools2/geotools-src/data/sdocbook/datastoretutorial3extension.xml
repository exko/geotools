<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article>
  <title>DataStore Tutorial 3: Extension</title>

  <para>In this document we will complete the PropertyDataStore started in
  DataStore Tutorial 1: Implementation. At the conclusion of this document we
  will have a full functional PropertyDataStore.</para>

  <sect1>
    <title>DataStore Tutorial</title>

    <para>In this series of documents we will build a simple a simple java
    property file based DataStore, and in the process explore several aspects
    of DataStores and their implementation.</para>

    <para>In this document we will add writing support to PropertyDataStore.</para>

    <para>DataStore Documents:<orderedlist><listitem><para>DataStore Tutorial
    1: Implementation</para></listitem><listitem><para>DataStore Tutorial 2:
    Use</para></listitem><listitem><para>DataStore Tutorial 3: Extension</para></listitem><listitem><para>DataStore
    Tutorial 4: Capabilities</para></listitem><listitem><para>DataStore
    Tutorial 5: Optimization</para></listitem></orderedlist></para>

    <para>We will be working with content in the following format:</para>

    <screen>_=id:Integer,geom:Geometry,name:String
rd1=1|wkt|road one
rd2=2|wkt|road two</screen>
  </sect1>

  <sect1>
    <title>PropertyDataStore Extension</title>

    <para>We are going to complete PropertyDataStore, by implementing the
    following methods:<itemizedlist><listitem><para>getFeatureWriter( typeName
    )</para></listitem><listitem><para>createSchema( featureType )</para></listitem></itemizedlist></para>

    <sect2>
      <title>Extending PropertyDataStore</title>

      <para>To start we need to make one change to our PropertyDataStore
      constructor:</para>

      <programlisting>    public PropertyDataStore(File dir) {
        super( true ); // changed to allow writing
        if( !dir.isDirectory()){
            throw new IllegalArgumentException( dir +&#34; is not a directory&#34;);
        }
        directory = dir;
    }</programlisting>

      <para>This change will tell AbstractDataStore that our subclass is
      willing to modify Features.</para>
    </sect2>

    <sect2>
      <title>Implement getFeatureWriter( typeName )</title>

      <para>FeatureWriter is the low-level api storing Feature content. This
      method is not part of the DataStore api.</para>

      <para>FeatureWriter:</para>

      <para>Add getFeatureWriter( typeName ):</para>

      <programlisting>protected FeatureWriter getFeatureWriter(String typeName) throws IOException {
    return new PropertiesFeatureWriter( this, typeName );
}</programlisting>

      <para>FeatureWriter is less intuitive then FeatureReader in that it does
      not follow the example of Iterator as closely.</para>

      <sect3>
        <title>PropertyFeatureWriter</title>

        <para>Our implementation of a FeatureWriter needs to do two things,
        support the FeatureWriter interface, and inform the the DataStore of
        modifications.</para>

        <para>FeatureWriter Interface:<itemizedlist><listitem><para>getFeatureType</para></listitem><listitem><para>hasNext</para></listitem><listitem><para>next</para></listitem><listitem><para>write</para></listitem><listitem><para>remove</para></listitem><listitem><para>close</para></listitem></itemizedlist></para>

        <para>Change notification is made available through several
        FeatureSource methods:</para>

        <itemizedlist>
          <listitem>
            <para>addFeatureListener( featureListener )</para>
          </listitem>

          <listitem>
            <para>removeFeatureListener( featureListener )</para>
          </listitem>
        </itemizedlist>

        <para>To trigger the featureListeners we will make use of several
        convience methods in AbstractDataSource:</para>

        <itemizedlist>
          <listitem>
            <para>fireAdded( feature )</para>
          </listitem>

          <listitem>
            <para>fireRemoved( feature )</para>
          </listitem>

          <listitem>
            <para>fireChanged( before, after )</para>
          </listitem>
        </itemizedlist>

        <para>Create the file PropertyFeatureWriter.java:</para>

        <programlisting>package org.geotools.data.property;

import java.io.*;

import org.geotools.data.*;
import org.geotools.feature.*;

public class PropertyFeatureWriter implements FeatureWriter {
    PropertyDataStore store;
        
    File read;
    PropertyAttributeReader reader;
    
    File write;
    PropertyAttributeWriter writer;
    
    Feature origional = null;
    Feature live = null;    
    public PropertyFeatureWriter( PropertyDataStore dataStore, String typeName ) throws IOException {
        store = dataStore;
        File dir = store.directory;        
        read = new File( dir, typeName+&#34;.properties&#34;);
        write = File.createTempFile( typeName+System.currentTimeMillis(), null, dir );        
                
        reader = new PropertyAttributeReader( read );
        writer = new PropertyAttributeWriter( write, reader.type );
    }

}</programlisting>

        <para>Our constructor creates a PropertyAttributeReader to access the
        existing contents of the DataStore. We made use of
        PropertyAttributeReader to implement PropertyFeatureReader in Tutorial
        1. </para>

        <para>We also create a PropertyAttributeWriter opperating against a
        temporary file. When the FeatureWriter is closed we will delete the
        origional file, and replace it with our new file. </para>

        <para>Add getFeatureType() implementation:</para>

        <programlisting>    public FeatureType getFeatureType() {
        return reader.type;
    }</programlisting>

        <para>Add hasNext() implementation:</para>

        <programlisting>    public boolean hasNext() throws IOException {
        if( live != null &#38;&#38; origional != null ){
            writeImplementation( origional );                                
            origional = null;
            live = null;
        }
        return reader.hasNext();
    }</programlisting>

        <para>Our FeatureWriter makes use of two Features:</para>

        <itemizedlist>
          <listitem>
            <para>origional: the feature provided by PropertyAttributeReader</para>
          </listitem>

          <listitem>
            <para>live: a duplicate of origional provided to the user for
            modification</para>
          </listitem>
        </itemizedlist>

        <para>When the FeatureWriter is used to write or remove information
        the contents of both live and feature are set to null. If this has not
        been done already we will write out the current feature.</para>

        <para>Add the helper function writeImplementation( Feature ):</para>

        <programlisting>    private void writeImplementation( Feature f ) throws IOException{
        writer.writeFeatureID( f.getID() );        
        for( int i=0; i&#60;f.getNumberOfAttributes(); i++){
            writer.write( i, f.getAttribute( i ));
        }
    }</programlisting>

        <para>Add next() implementation:</para>

        <programlisting>    public Feature next() throws IOException {
        String fid = null;
        FeatureType type = reader.type;                                
        try {
            if( hasNext() ){
                reader.next(); // grab next line
                
                fid = reader.getFeatureID();
                Object values[] = new Object[ reader.getAttributeCount() ];
                for( int i=0; i&#60; reader.getAttributeCount(); i++){
                    values[i]=reader.read( i );
                }                            
                origional = type.create( values, fid );
                live = type.duplicate( origional );
                return live;
            }
            else {
                fid = type.getTypeName()+&#34;.&#34;+System.currentTimeMillis();
                Object values[] = DataUtilities.defaultValues( type );
                origional = null;                                            
                live = type.create( values, fid );
                return live;    
            }                    
        } catch (IllegalAttributeException e) {
            throw new IOException( &#34;Problem creating feature &#34;+fid );
        }
    }</programlisting>

        <para>The method next is used for two purposes:</para>

        <itemizedlist>
          <listitem>
            <para>To access Features for modification or removal</para>
          </listitem>

          <listitem>
            <para>To create new Features</para>
          </listitem>
        </itemizedlist>

        <para>To access existing Features the AttributeReader is advanced, the
        current attribtue and feature ID assembled into a Feature. This
        Feature is then duplicated and returned to the user. We will later
        compare the the origional to the user&#39;s copy to check if any
        modification have been made.</para>

        <para>Add write() implementation:</para>

        <programlisting>    public void write() throws IOException {
        if( live == null){
            throw new IOException( &#34;No current feature to write&#34;);            
        }
        if( live.equals( origional )){
            writeImplementation( origional );                        
        }
        else {
            writeImplementation( live );
            if( origional != null){
                store.fireChanged( origional, live );                
            }
            else {
                store.fireAdded( live );
            }            
        }
        origional = null;
        live = null;
    }</programlisting>

        <para>In the write method we will need to check to see the user has
        changed anything, if so we will need to remember to fiew event
        notification after writing out their changes.</para>

        <para>Add remove() implementation:</para>

        <programlisting>    public void remove() throws IOException {
        if( live == null){
            throw new IOException( &#34;No current feature to remove&#34;);
        }
        if( origional != null ){
            store.fireRemoved( origional );
        }                     
        origional = null; 
        live = null; // prevent live and remove from being written out       
    } </programlisting>

        <para>To implement remove, we simply won&#39;t write out the the
        origional Feature.</para>

        <para>Add close() Implementation:</para>

        <programlisting>public void close() throws IOException {
        if( writer == null ){
            throw new IOException( &#34;writer already closed&#34;);            
        }
        while( reader.hasNext() ){
            reader.next(); // advance
            writer.next();             
            writer.echoLine( reader.line ); // echo unchanged                        
        }
        writer.close();
        reader.close();        
        writer = null;
        reader = null;        
        read.delete();
        write.renameTo( read );
        read = null;
        write = null;        
        store = null;                
    }</programlisting>

        <para>To implement close() we must remember to write out any remaining
        features in the DataStore before closing our new file. To implement
        this we have performed a small optimization: we simply echo the line
        aquired by the PropertyFeatureReader.</para>

        <para>The last thing our FeatureWriter must do is replace the existing
        File with our new one.</para>
      </sect3>

      <sect3>
        <title>PropertyAttributeWriter</title>

        <para>In the previous section we explored the capabilities of our
        PropertyWriter through actual use.</para>

        <para>Create PropertyAttributeWriter:</para>

        <programlisting>package org.geotools.data.property;

import java.io.*;
import org.geotools.data.*;
import org.geotools.feature.*;
import com.vividsolutions.jts.geom.Geometry;

public class PropertyAttributeWriter implements AttributeWriter {
    BufferedWriter writer;    
    FeatureType type;    
    public PropertyAttributeWriter( File file, FeatureType featureType ) throws IOException {
        writer = new BufferedWriter( new FileWriter( file ) );
        type = featureType;                
        writer.write( &#34;_=&#34; );
        writer.write( DataUtilities.spec( type ) );                                        
    }
    public int getAttributeCount() {
        return type.getAttributeCount();
    }
    public AttributeType getAttributeType(int index) throws ArrayIndexOutOfBoundsException {
        return type.getAttributeType(index);
    }
}</programlisting>

        <para>A BufferedWriter is created over the provided File, and the
        provided featureType is used to implement getAttribtueCount() and
        getAttributeType( index ).</para>

        <para>Add hasNext() and next() implementations:</para>

        <programlisting>    public boolean hasNext() throws IOException {
        return false;
    }    
    public void next() throws IOException {
        writer.newLine();
        writer.flush();
    }</programlisting>

        <para>Our FeatureWriter does not provide any content of its own,
        FeatureWriters that are backed by JDBC ResultSets or random access
        file may use hasNext() to indicate that the they are streaming over
        existing content.</para>

        <para>Or implementation of next() will simply start a newLine for the
        feature that is about to be written.</para>

        <para>Add writeFeatureID():</para>

        <programlisting>    public void writeFeatureID( String fid ) throws IOException{
        if( writer == null){
            throw new IOException(&#34;Writer has been closed&#34;);
        }        
        writer.write( fid );                
    }</programlisting>

        <para>Our file format is capable of storing FeatureIDs, many
        DataStores will need to derive or encode FeatureID information into
        their Attribtues.</para>

        <para>Add write( int index, Object value ):</para>

        <programlisting>    public void write(int position, Object attribute) throws IOException {
        writer.write( position == 0 ? &#34;=&#34; : &#34;|&#34; );
        if( attribute instanceof Geometry){
            writer.write( ((Geometry)attribute).toText() );
        }
        else {
            writer.write( attribute.toString() );
        }
    }</programlisting>

        <para>Our implementation needs to prepend a equals sign before the
        first Attribute, or a bar for any other attribtue. We also make sure
        to encode Geometry as wkt.</para>

        <para>Add close():</para>

        <programlisting>    public void close() throws IOException {
        writer.close();
        writer = null;
        type = null;        
    }</programlisting>

        <para>Finally, to implement our FeatureWriter.close() optimization, we
        need to implement echoLine():</para>

        <programlisting>    public void echoLine( String line ) throws IOException{
        if( line == null ){
            return;
        }
        writer.write( line );
    }</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>DataStore - createSchema( featureType)</title>

      <para>This method provides the ability to create new FeatureType. For
      our DataStore we will use this to create new properties files.</para>

      <para>To implement this method we will once again make use of the
      DataUtilities class.</para>

      <para>Add createSchmea( featureType ):</para>

      <programlisting>public void createSchema(FeatureType featureType) throws IOException {
    String typeName = featureType.getTypeName();
    File file = new File( path, typeName+&#34;.properties&#34;);
    BufferedWriter writer = new BufferedWriter( new FileWriter( file ) );
    writer.write(&#34;_=&#34;);
    writer.write( DataUtilities.spec( featureType ) );
    writer.close();
} </programlisting>
    </sect2>
  </sect1>
</article>