<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article>
  <title>DataStore Tutorial 1: Implementation</title>

  <para>The GeoTools project strives to support as many geographical data
  formats as possible because getting data into the GeoTools API allows access
  to a vast suite of tools. In order to transform a data format into the
  GeoTools feature representation one must write an implementation of the
  DataStore interface.</para>

  <para>Once a DataStore implementation is written, any data written in that
  format becomes available not only for GeoTools users, but also for projects
  built on top of GeoTools.</para>

  <para>Writing a new DataStore for GeoTools is one of the best ways to get
  involved in the project, as writing it will make clear many of the core
  concepts of the API. Finally, the modular nature of GeoTools allows new
  DataStores to quickly become part of the next release, so that new formats
  are quickly available to all GeoTools users.</para>

  <para>The DataStore interface borrows most of its concepts and some of its
  syntax from the OpenGIS Consortium (OGC) Web Feature Server Specification:<itemizedlist><listitem><para>Feature
  - atomic unit of geographic information</para></listitem><listitem><para>FeatureType
  - keeps track of what attributes each Feature can hold</para></listitem><listitem><para>FeatureID
  - a unique id associated with each Feature (must start with a non-numeric
  character)</para></listitem></itemizedlist></para>

  <sect1>
    <title>DataStore Tutorial</title>

    <para>In this series of documents we will build a simple a simple Java
    property file based DataStore, and in the process explore several aspects
    of DataStores and their implementation.</para>

    <para>DataStore Documents:<orderedlist><listitem><para>DataStore Tutorial
    1: Implementation</para></listitem><listitem><para>DataStore Tutorial 2:
    Use</para></listitem><listitem><para>DataStore Tutorial 3: Extension</para></listitem><listitem><para>DataStore
    Tutorial 4: Capabilities</para></listitem><listitem><para>DataStore
    Tutorial 5: Optimization</para></listitem></orderedlist></para>

    <para>We will be working with content in the following format:</para>

    <screen>_=id:Integer,geom:Geometry,name:String
rd1=1|wkt|road one
rd2=2|wkt|road two</screen>

    <para>If you want to follow a long with this tutorial, start a new Java
    project in your favourite IDE, and ensure that geotools2 is on you
    classpath.</para>
  </sect1>

  <sect1>
    <title>PropertyDataStore Implementation</title>

    <para>The first step is to create a basic DataStore that only supports
    feature extraction. We will read data from a properties file into the
    GeoTools feature model.</para>

    <sect2>
      <title>Extending AbstractDataStore</title>

      <para>To implement a DataStore we will subclass AbstractDataStore and
      implement three abstract methods:</para>

      <itemizedlist>
        <listitem>
          <para>getTypeNames()</para>
        </listitem>

        <listitem>
          <para>getSchema( typeName )</para>
        </listitem>

        <listitem>
          <para>getFeatureReader( typeName )</para>
        </listitem>
      </itemizedlist>

      <para>To begin create the file PropertyDataStore as follows:</para>

      <programlisting>package org.geotools.data.property;

import java.io.*;

import org.geotools.data.*;
import org.geotools.feature.*;

public class PropertyDataStore extends AbstractDataStore {
    protected File directory;
    public PropertyDataStore(File dir) {
        super( false ); // does not allow writing
        if( !dir.isDirectory()){
            throw new IllegalArgumentException( dir +&#34; is not a directory&#34;);
        }
        directory = dir;
    }
}</programlisting>
    </sect2>

    <sect2>
      <title>getTypeNames()</title>

      <para>A DataStore may provide access to several different types of
      information. The method getTypeNames provides a list of the available
      types.</para>

      <para>For our purposes this list will be the name of the property files
      in a directory.</para>

      <para>Add getTypeNames():</para>

      <programlisting>    public String[] getTypeNames() {
        FilenameFilter f;
        String list[] = directory.list( new FilenameFilter(){
            public boolean accept(File dir, String name) {
                return name.endsWith(&#34;.properties&#34;);
            }
        });
        for( int i=0; i&#60;list.length;i++){
            list[i] = list[i].substring(0, list[i].lastIndexOf(&#39;.&#39;));
        }
        return list;
    }</programlisting>
    </sect2>

    <sect2>
      <title>getSchema( typeName )</title>

      <para>Schema information is provided by the FeatureType class. This
      method provides access to a FeatureType referenced by a type name.</para>

      <para>To implement this method we will need to do two things, read a
      line from a properties file, and interpret the line as a FeatureType.</para>

      <para>The DataUtilities class provides an assortment of helper
      functions. In this method we will use DataUtilities.createType( name,
      spec ).</para>

      <para>Add getSchema( typeName ):</para>

      <programlisting>    public FeatureType getSchema(String typeName) throws IOException {
        String typeSpec = property( typeName, &#34;_&#34;);
        try {
            String namespace = directory.getName();
            return DataUtilities.createType( namespace+&#34;.&#34;+typeName,typeSpec );
        } catch (SchemaException e) {
            e.printStackTrace();
            throw new DataSourceException( typeName+&#34; schema not available&#34;, e);
        }
    }</programlisting>

      <para>Add property( typeName, key ):</para>

      <programlisting>    private String property( String typeName, String key ) throws IOException {
        File file = new File( directory, typeName+&#34;.properties&#34;);
        BufferedReader reader = new BufferedReader( new FileReader( file ) );
        try {        
            for( String line = reader.readLine(); line != null; line = reader.readLine()){
                if( line.startsWith( key+&#34;=&#34; )){
                    return line.substring( key.length()+1 );
                }
            }
        }
        finally {
            reader.close();            
        }        
        return null;        
    }</programlisting>
    </sect2>

    <sect2>
      <title>getFeatureReader( typeName )</title>

      <para>FeatureReader is the low-level API provided by DataStore for
      accessing Feature content.</para>

      <para>The method getFeatureReader( typeName ) is required by
      AbstractDataStore and is not part of the DataStore API.</para>

      <para>Add getFeatureReader( typeName ):</para>

      <programlisting>    protected FeatureReader getFeatureReader(String typeName) throws IOException {
        return new PropertyFeatureReader( directory, typeName );        
    }</programlisting>

      <sect3>
        <title>PropertyFeatureReader</title>

        <para>FeatureReader is similar to the Java Iterator construct, with
        the addition of FetureType (and IOExceptions).</para>

        <para>FeatureReader interface:<itemizedlist><listitem><para>getFeatureType()</para></listitem><listitem><para>next()</para></listitem><listitem><para>hasNext()</para></listitem><listitem><para>close()</para></listitem></itemizedlist></para>

        <para>To implement our FeatureReader, we will need to do several
        things: open a File, read through it line by line parsing Features as
        we go.</para>

        <para>Create the file PropertyFeatureReader as follows:</para>

        <para><programlisting>package org.geotools.data.property;

import java.io.*;
import java.util.NoSuchElementException;

import org.geotools.data.*;
import org.geotools.feature.*;

public class PropertyFeatureReader implements FeatureReader {
    PropertyAttributeReader reader;    
    public PropertyFeatureReader( File directory, String typeName ) throws IOException {
        File file = new File( directory, typeName+&#34;.properties&#34;);
        reader = new PropertyAttributeReader( file );                        
    }
    public FeatureType getFeatureType() {
        return reader.type;
    }
    public Feature next()
        throws IOException, IllegalAttributeException, NoSuchElementException {
        reader.next();            
        FeatureType type = reader.type;
        String fid = reader.getFeatureID();
        Object values[] = new Object[ reader.getAttributeCount() ];
        for( int i=0; i&#60; reader.getAttributeCount(); i++){
            values[i]=reader.read( i );
        }
        return type.create( values, fid );                
    }
    public boolean hasNext() throws IOException {
        return reader.hasNext();
    }
    public void close() throws IOException {
        reader.close();
        reader = null;        
    }
}</programlisting></para>

        <para>The helper class PropertyAttributeRedaer will be used to
        accomplish the bulk of this work.</para>
      </sect3>

      <sect3>
        <title>PropertyAttributeReader</title>

        <para>The AttributeReader interface is used to provide access to
        individual attributes from a storage medium. High level operations,
        such as Joining make use of this capability.</para>

        <para>AttributeReader interface:</para>

        <itemizedlist>
          <listitem>
            <para>getAttributeCount</para>
          </listitem>

          <listitem>
            <para>hasNext( index )</para>
          </listitem>

          <listitem>
            <para>next()</para>
          </listitem>

          <listitem>
            <para>read(int)</para>
          </listitem>

          <listitem>
            <para>getAttributeType( index )</para>
          </listitem>

          <listitem>
            <para>close()</para>
          </listitem>
        </itemizedlist>

        <para>Create the file PropertyAttributeReader as follows:</para>

        <programlisting>package org.geotools.data.property;

import java.io.IOException;

import java.io.*;
import java.util.NoSuchElementException;

import org.geotools.data.*;
import org.geotools.feature.*;

public class PropertyAttributeReader implements AttributeReader {
    BufferedReader reader;
    FeatureType type;
    String line;
    String next;
    
    public PropertyAttributeReader( File file ) throws IOException {
        String typeName = typeName( file );
        String namespace = namespace( file );    
        reader = new BufferedReader( new FileReader( file )  );
        line = reader.readLine();                        
        if( line == null || !line.startsWith(&#34;_=&#34;)){
            throw new IOException( typeName+&#34; schema not available&#34; );            
        }
        String typeSpec = line.substring(2);
        try {            
            type = DataUtilities.createType( namespace+typeName, typeSpec );
            
        } catch (SchemaException e) {As shown above
            throw new DataSourceException( typeName+&#34; schema not available&#34;, e );
        }        
        line = null;
        next = null;        
    }
    private static String typeName( File file ){
        String name = file.getName();
        int split = name.lastIndexOf(&#39;.&#39;);
        return split == -1 ? name : name.substring(0, split );        
    }
    private static String namespace( File file ){
        File parent = file.getParentFile();
        return parent == null ? &#34;&#34; : parent.getName()+&#34;.&#34;;
    }
}</programlisting>

        <para>Our constructor acquires the type information from the header,
        using a function form DataUtiltiies to interpret the type
        specification. The filename is used as the name for the resulting
        FeatureType, and the directory name is used for the name space.</para>

        <para>The BufferedReader, reader, is opened and it will be this class
        will allows us to stream over contents as a series of Features.</para>

        <para>We will use a two part strategy for determining if more content
        is available. We will try and acquire the &#39;next&#39; line in the
        hasNext() method, using the next() method to update &#39;line&#39; to
        the contents of &#39;next&#39;. All attribute operations will be
        performed against the current &#39;line&#39;.</para>

        <para>With these ideas in mind we can implement the required methods:</para>

        <programlisting>    public int getAttributeCount() {
        return type.getAttributeCount();
    }        
    public AttributeType getAttributeType(int index)
        throws ArrayIndexOutOfBoundsException {
        return type.getAttributeType( index );
        
    }
    public void close() throws IOException {
        reader.close();
        reader = null;
    }
    public boolean hasNext() throws IOException {        
        if( next != null){
            return true;
        }
        next = reader.readLine();
        return next != null;
    }
    public void next() throws IOException {
        if( hasNext() ){
            line = next;
            next = null;
        }
        else {
            throw new NoSuchElementException();        
        }
    }    
    public Object read(int index)
        throws IOException, ArrayIndexOutOfBoundsException {
        if( line == null ){
            throw new IOException( &#34;No content available - did you remeber to call next?&#34; );            
        }
        int split = line.indexOf(&#39;=&#39;);
        String fid = line.substring( 0, split );
        String text[] = line.substring( split+1 ).split(&#34;\\|&#34;);
        return type.getAttributeType( index ).parse( text[ index ] );
    }</programlisting>

        <para>Finally since our file format does support FeatureID we will
        need a way to let our FeatureReader know:</para>

        <programlisting>    public String getFeatureID(){
        if( line == null ){
            return null;
        }
        int split = line.indexOf(&#39;=&#39;);
        if( split == -1){
            return null;
        }
        return line.substring( 0, split );        
    }</programlisting>

        <para>We can make use of getFeatureID() to supply a FeatureID for
        FeatureReader, many other DataStores derive a FeatureID from the
        attributes.</para>

        <para>A common approach is to take a unique AttributeType, which is a
        number, and prepend the typename. This allows the creation of a unique
        identifier that does not start with a number.</para>

        <para>FeatureID generation example:</para>

        <screen>public String deriveFeatureID(){
    return type.getTypeName()+&#34;.&#34;+Integer.parse( read( 0 ).toString() );
}</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>DataStore Factory Implementation</title>

    <para>To make your DataStore truly independent and pluggable, your must
    create a class implementing the DataStoreFactorySpi interface.</para>

    <para>This allows the Service Provider Interface mechanism to dynamically
    plug in your new DataStrore with no implementation knowledge. Code that
    uses the DataStoreFinder can just add the new DataStore to the classpath
    and it will work!</para>

    <para>This code operates by looking at the services file:
    META-INF/services/org.GeoTools.data.DataStoreFactorySpi. This file
    requires the filename of the factory that implements the DataStoreSpi
    interface.</para>

    <para>Example org.GeotTools.data.DataStoreFactorySpi file:</para>

    <screen>org.GeoTools.data.tutorial.PropertiesDataStoreFactory</screen>

    <para>The DataStoreFactorySpi provides information on the Parameters
    required for construction, DataStoreFactoryFinder provides the ability to
    create DataStores representing existing information, and the ability to
    create new physical storage.</para>

    <para>Create PropertyDataStoreFactory as follows:</para>

    <programlisting>package org.geotools.data.property;

import org.geotools.data.DataStore;
import org.geotools.data.DataStoreFactorySpi;
import java.io.File;
import java.io.IOException;
import java.util.Map;

public class PropertyDataStoreFactory implements DataStoreFactorySpi {
    public DataStore createDataStore(Map params) throws IOException {
        File dir = (File) params.get(&#34;directory&#34;);        
        return new PropertyDataStore( dir );
    }
    public DataStore createNewDataStore(Map params) throws IOException {
        File dir = (File) params.get(&#34;directory&#34;);
        if (dir.exists()) {
            throw new IOException(dir + &#34; already exists&#34;);
        }
        boolean created;       
        created = dir.mkdir();
        if (!created) {
            throw new IOException(&#34;Could not create the directory&#34; + dir);
        }
        return new PropertyDataStore(dir);
    }
    public String getDescription() {
        return &#34;Allows access to Java Property files containing Feature information&#34;;
    }
    public Param[] getParametersInfo() {
        Param directory = new Param(&#34;directory&#34;, File.class,
                &#34;Directory containting property files&#34;, true);

        return new Param[] { directory, };
    }
    public boolean canProcess(Map params) {
        return (params != null) &#38;&#38; params.containsKey(&#34;directory&#34;)
        &#38;&#38; params.get(&#34;directory&#34;) instanceof File;
    }
}</programlisting>
  </sect1>
</article>