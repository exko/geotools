/* Copyright (c) 2001 Vision for New York - www.vfny.org.  All rights reserved.
 * This code is released under the Apache license, availible at the root GML4j directory.
 */
package org.geotools.gml;

import java.util.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;

import com.vividsolutions.jts.geom.*;


/**
 * LEVEL3 GML filter: translates JTS elements and attribute data into features.
 *
 * <p>This filter simply reads in the events and coordinates passed to it by
 * its GMLFilterDocument child
 * and converts them into JTS objects.  Note that it passes through anything not specifically sent to it by
 * GMLFilterDocument (i.e. more or less everything not in geometry.xsd).  The parent of this filter must
 * implement GMLHandlerJTS in order to receive the JTS objects passed by this filter.</p>
 * 
 * @author Rob Hranac, Vision for New York
 * @version alpha, 12/01/01
 */
public class GMLFilterFeature extends XMLFilterImpl implements GMLHandlerJTS {


		/** Handler for the JTS elements generated by this filter */
    private GMLHandlerFeature parent;  
    
		/** Factory for the JTS geometries. */
		private FlatFeature currentFeature = new FlatFeature();

		/** Stores current feature attributes */
		private Vector attributes = new Vector();

		/** Stores current feature attributes */
		private boolean insideAttribute = false;

		/** Stores current feature attributes */
		private boolean insideFeature = false;

		/** Stores current feature attributes */
		private boolean insideGeometry = false;

		/** Stores current feature attributes */
		private Object tempValue = null;

		//private FeatureSchema metadata = new FeatureSchema();

		// Static Globals to handle some expected elements
		/** GML namespace string */
		private static final String GML_NAMESPACE = "http://www.opengis.net/gml";
		/** Sub geometry elements that may be passed in GML */
		private static final String FEATURE_MEMBER_NAME = "featureMember";  


		/**
		 * Constructor with parent, which must implement GMLHandlerJTS.
		 *
		 * @param parent The parent of this filter.
		 */
		public GMLFilterFeature (GMLHandlerFeature parent) {
				super();
				this.parent = parent;
		}


		/**
		 * Constructor with parent, which must implement GMLHandlerJTS.
		 *
		 * @param parent The parent of this filter.
		 */
		public void setSchema (String uri) {
		}


		/**
		 * Manages the start of a new main or sub geometry.  This method looks at the status of the current handler
		 * and either returns a new sub-handler (if the last one was successfully returned already) or passes the 
		 * element start notification along to the current handler as a sub geometry notice.
		 *
		 * @param geometry The geometry from the child.
		 */
		public void geometry(Geometry geometry) {
				insideGeometry = true;
				currentFeature.setGeometry(geometry);
		}


		/**
		 * Checks for GML element start and - if not a coordinates element - sends it directly on down the chain to the appropriate
		 * parent handler.  If it is a coordinates (or coord) element, it uses internal methods to set the current state of the
		 * coordinates reader appropriately. 
		 *
		 * @param namespaceURI The namespace of the element.
		 * @param localName The local name of the element.
		 * @param qName The full name of the element, including namespace prefix.
		 * @param atts The element attributes.
		 * @throws SAXException Some parsing error occured while reading coordinates.
		 */
		public void startElement(String namespaceURI, String localName, String qName, Attributes atts)
				throws SAXException {

				// if at a GML element, do some checks to determine how to handle the element
				if( namespaceURI.equals(GML_NAMESPACE) ) {

						// if geometry, pass it on down the filter chain
					  if ( FEATURE_MEMBER_NAME.equals(localName) ) {
								attributes = new Vector();
						}								
				}
				else if (insideFeature) {
						insideAttribute = true;
				}
				else {
						insideFeature = true;
				}
		}


		/**
		 * Reads the only internal characters read by a pure GML parsers, which are coordinates.  These coordinates
		 * are sent to the coordinates reader class, which interprets them appropriately, depeding on the its current
		 * state.
		 *
		 * @param ch Raw coordinate string from the GML document.
		 * @param start Beginning character position of raw coordinate string.
		 * @param length Length of the character string.
		 * @throws SAXException Some parsing error occured while reading coordinates.
		 */
		public void characters(char[] ch, int start, int length)
				throws SAXException {

				// the methods here read in both coordinates and coords and take the grunt-work out of this task for geometry handlers
				// see the documentation for CoordinatesReader to see what this entails
				String rawAttribute = new String(ch, start, length);

				if( insideAttribute ) { 
						try {
								tempValue = new Integer(rawAttribute);
						} catch ( NumberFormatException e1 ){
								try {
										tempValue = new Double(rawAttribute);
								} catch ( NumberFormatException e2 ){
										tempValue = new String(rawAttribute);
								}
						}
						
				}
		}
		

		/**
		 * Checks for GML element end and - if not a coordinates element - sends it directly on down the chain to the appropriate
		 * parent handler.  If it is a coordinates (or coord) element, it uses internal methods to set the current state of the
		 * coordinates reader appropriately.
		 *
		 * @param namespaceURI The namespace of the element.
		 * @param localName The local name of the element.
		 * @param qName The full name of the element, including namespace prefix.
		 * @throws SAXException Some parsing error occured while reading coordinates.
		 */
		public void endElement(String namespaceURI, String localName, String qName)
				throws SAXException {


				// if at a GML element, do some checks to determine how to handle the element
				if( namespaceURI.equals(GML_NAMESPACE) ) {

						// if geometry, pass it on down the filter chain
					  if ( FEATURE_MEMBER_NAME.equals(localName) ) {
								currentFeature.setAttributes((Object []) attributes.toArray());
								parent.feature( currentFeature );
								currentFeature = new FlatFeature();
						}								
				}
				else if (insideAttribute) {
						if( !insideGeometry ) {
								attributes.add( tempValue );
						}
						else {
								insideGeometry = false;
						}
						insideAttribute = false;
				}
				else {
						insideFeature = false;
				}
		}		





}
