Geometry
--------

To create a Geometry object we make use of the GeometryFactory provided by JTS. GeometryFactory has a bunch of create methods that take Coordinate instances (and arrays) and wrap them up in the appropriate instance of Geometry.

.. image:: /images/geometry.PNG

You can create your own GeometryFactory with a specific PrecisionModel and CoordinateSequenceFactory. These configuration options are only of interest if you are wanting your Coordinates to store values as floats rather than doubles.

The GeometryFactory created by default works just fine.

Creating a Point
^^^^^^^^^^^^^^^^

This time we are using a JTS GeometryFactory, although you can create one yourself (if you want to fiddle with Precision}} there is a global one available using the FactoryFinder.:

.. literalinclude:: /../src/main/java/org/geotools/geometry/GeometryExamples.java
   :language: java
   :start-after: // createPoint start
   :end-before: // createPoint end

"Well Known Text" is a simple text format defined by the Simple Feature for SQL specification:

.. literalinclude:: /../src/main/java/org/geotools/geometry/GeometryExamples.java
  :language: java
  :start-after: // createPointWKT start
  :end-before: // createPointWKT end

If you need to represent many points (perhaps fence posts forming a fence) you can use use a MultiPoint.

Creating a LineString
^^^^^^^^^^^^^^^^^^^^^


.. image:: /images/geometry_linestring.png

The following makes a line string in the shape of a check mark::
   
   GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory( null );
   
   Coordinate[] coords  =
    new Coordinate[] {new Coordinate(0, 2), new Coordinate(2, 0), new Coordinate(8, 6) };
   
   LineString line = geometryFactory.createLineString(coordinates);

Alternative - Reading a LineString from WKT::
   
   GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory( null );
   
   WKTReader reader = new WKTReader( geometryFactory );
   LineString line = (LineString) reader.read("LINESTRING(0 2, 2 0, 8 6)");

If you need to represent a line with gaps in it you can use a MultiLineString.

Creating a Polygon
^^^^^^^^^^^^^^^^^^


.. image:: /images/geometry_polygon.png

The following makes a Polygon in the shape of a square::

   GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory( null );
   
   Coordinate[] coords  =
      new Coordinate[] {new Coordinate(4, 0), new Coordinate(2, 2),
                        new Coordinate(4, 4), new Coordinate(6, 2), new Coordinate(4, 0) };

   LinearRing ring = geometryFactory.createLinearRing( coords );
   LinearRing holes[] = null; // use LinearRing[] to represent holes
   Polygon polygon = geometryFactory.createPolygon(ring, holes );
   
Alternative - Reading a Polygon from WKT::
   
   GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory( null );
   
   WKTReader reader = new WKTReader( geometryFactory );
   Polygon polygon = (Polygon) reader.read("POLYGON((20 10, 30 0, 40 10, 30 20, 20 10))");

You can also create a Polygon will holes in it. And once again use a MultiPolygon to represent a single geometry made up of distinct shapes.


Arcs, Circles and Curves
^^^^^^^^^^^^^^^^^^^^^^^^

The JTS Topology Suite does not have any constructs to represent a "curve" or "circle" - it is strictly limited to geometry made up of straight (ie linear) lines.

In order to represent circles and curves you will need to produce them (yourself) using a little bit of math. If there is general interest in these kinds of functions we can add them to the GeoTools library.

Creating a Circle::
   
   private static Geometry createCircle(double x, double y, final double RADIUS) {
       final int SIDES = 32;
       Coordinate coords[] = new Coordinate[SIDES+1];
       for( int i = 0; i < SIDES; i++){
           double angle = ((double) i / (double) SIDES) * Math.PI * 2.0;
           double dx = Math.cos( angle ) * RADIUS;
           double dy = Math.sin( angle ) * RADIUS;
           coords[i] = new Coordinate( (double) x + dx, (double) y + dy );
       }
       coords[SIDES] = coords[0];
   
       LinearRing ring = factory.createLinearRing( coords );
       Polygon polygon = factory.createPolygon( ring, null );
      
       return polygon;
   }

Another approach is to create a curve or shape object with one of Java's handy Shape classes and then extract the coordinates from that object to create your geometry.

Arcs without the maths::
   
   private static Geometry createBezierCurve(Coordinate start,
                                             Coordinate end,
                                             Coordinate ctrlPoint1,
                                             Coordinate ctrlPoint2
                                             double smooth) {
       Shape curve = new CubicCurve2D.Double(
           start.x, start.y,
           ctrlPoint1.x, ctrlPoint1.y,
           ctrlPoint2.x, ctrlPoint2.y,
           end.x, end.y);
      
       // the value of the smooth arg determines how closely the line
       // segments between points approximate the smooth curve
       // (see javadocs for Shape.getPathIterator method)
      
       PathIterator iter = curve.getPathIterator(null, smooth);
      
       // a length 6 array is required for the iterator
       double[] iterBuf = new double[6];
   
       List<Coordinate> coords = new ArrayList<Coordinate>();
       while (!iter.isDone()) {
           iter.currentSegment(iterBuf);
           coords.add(new Coordinate(buf[0], buf[1]);
           iter.next();
       }
      
       GeometryFactory gf = new GeometryFactory();
       return gf.createLineString(coords.toArray(new Coordinate[coords.size()]));
   }

Here's an example of some randomly orientated and shaped curves generated in this way...

.. image:: /images/geometry_curve.gif

Sometimes you need to generate a smooth curve that is guaranteed to pass through a specified set of points. The tried and true approach here is to use a spline function. This generates a set of polynomial (cubic) curves, each of which fits a part of the data and joins smoothly to its neighbouring curves.

Splines (arcs with maths galore)::
   
   
   Coordinate[] myPoints = new Coordinate[] {
               new Coordinate(0,0),
               new Coordinate(3,6),
               new Coordinate(9,12),
               new Coordinate(12,6),
               new Coordinate(15,4),
               new Coordinate(20,10),
               new Coordinate(26,18),
               new Coordinate(29,16),
               new Coordinate(32,13),
               new Coordinate(37,18),
               new Coordinate(43,24),
               new Coordinate(50,16)
           };
   
   SplineInterpolator si = new SplineInterpolator();
   
   // generate a curve represented by 100 points plus the input points
   Coordinate[] interpPoints = si.interpolate(myPoints, 100, true);
   
   GeometryFactory gf = new GeometryFactory();
   gf.createLineString(coords.toArray(new Coordinate[coords.size()]));

Here is the generated spline curve with the location of the input coordinates shown...

.. image:: /images/geometry_spline.gif

And here is the code for the SplineInterpolator class...::
  
  /*
   * Copyright 2009 Michael Bedward
   *
   * This file is part of jai-tools
   *
   * jai-tools is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as
   * published by the Free Software Foundation, either version 3 of the
   * License, or (at your option) any later version.
   * jai-tools is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Lesser General Public License for more details.
   * You should have received a copy of the GNU Lesser General Public
   * License along with jai-tools.  If not, see <http://www.gnu.org/licenses/>.
   *
   */
  package jaitools.util;
  
  import com.vividsolutions.jts.geom.Coordinate;
  
  /**
   * A utility class for cubic spline interpolation in two dimensions.
   *
   * @author Michael Bedward
   */
  public class SplineInterpolator {
  
    /**
     * Cubic spline interpolation through the set of points with
     * coordinates given by x and y input arrays.
     * <P>
     * Returns the coords of a line interpolated through np points
     * (including the first and last control points) which are
     * approximately evenly-spaced (fudged using linear interp).
     * <P>
     * Adapted from an algorithm in Press et al. 1992
     * "Numeical Recipes in C". Cambridge University Press
     *
     * @param ctrlCoords the 'control points' that the interpolated curve must pass through
     * @param numPoints number of interpolation points
     * @param includeCtrlCoords if true the returned Coordinates will include the input
     * control points; if false only the first and last control points are guaranteed to
     * be included (though the curve still passes through the other points)
     *
     * @return array of interpolated Coordinates
     *
     * @throws java.lang.IllegalArgumentException
     */
    public Coordinate[] interpolate(Coordinate[] ctrlCoords, int numPoints, boolean includeCtrlCoords)
            throws IllegalArgumentException {

        int N = ctrlCoords.length;
        if (numPoints <= N) {
            throw new IllegalArgumentException(
                    "np should be larger than length of input coords array");
        }

        // x values need to be considered in ascending order
        int[] o = getXOrder(ctrlCoords);

        // Interpolation (as done below) will fail if any of the input
        // coordinates x values are equal
        double prec = 1.0e-8;
        for (int i = 1; i < N; i++) {
            if (Math.abs(ctrlCoords[o[i]].x - ctrlCoords[o[i - 1]].x) < prec) {
                // jiggle the second coord
                ctrlCoords[o[i - 1]].x += 2 * prec;
            }
        }

        // first derivatives
        double[] dy = new double[N];

        // second derivatives
        double[] ddy = new double[N];

        /*
         * In this implementation we set the value of the second
         * derivatives at the end-points to 0 (the so-called natural
         * cublic spline). See Press et al. 1992 for alternative
         * approaches.
         */
        ddy[0] = ddy[N - 1] = dy[0] = 0.0;

        // tridiagonal algorithm to calculate the piece-wise splines
        double sig, p;
        for (int i = 1; i < N - 1; i++) {
            sig = (ctrlCoords[o[i]].x - ctrlCoords[o[i - 1]].x) / (ctrlCoords[o[i + 1]].x - ctrlCoords[o[i - 1]].x);
            p = sig * ddy[i - 1] + 2.0;
            ddy[i] = (sig - 1.0) / p;
            dy[i] = (ctrlCoords[o[i + 1]].y - ctrlCoords[o[i]].y) / (ctrlCoords[o[i + 1]].x - ctrlCoords[o[i]].x) - (ctrlCoords[o[i]].y - ctrlCoords[o[i - 1]].y) / (ctrlCoords[o[i]].x - ctrlCoords[o[i - 1]].x);
            dy[i] = (6.0d * dy[i] / (ctrlCoords[o[i + 1]].x - ctrlCoords[o[i - 1]].x) - sig * dy[i - 1]) / p;
        }

        for (int i = N - 2; i >= 0; i--) {
            ddy[i] = ddy[i] * ddy[i + 1] + dy[i];
        }

        // interpolation

        // first find approximate distance along curve by linear interp
        double[] dist = new double[N];
        double[] xdiff = new double[N];
        dist[0] = xdiff[0] = 0.0;
        for (int i = 1; i < N; i++) {
            xdiff[i] = ctrlCoords[o[i]].x - ctrlCoords[o[i - 1]].x;
            double ydiff = ctrlCoords[o[i]].y - ctrlCoords[o[i - 1]].y;
            dist[i] = dist[i - 1] + Math.sqrt(xdiff[i] * xdiff[i] +
                    ydiff * ydiff);
        }

        // spacing
        double dIncr = dist[N - 1] / (numPoints - 1);

        Coordinate[] interpCoords;
        if (includeCtrlCoords) {
            interpCoords = new Coordinate[numPoints + N - 2];
        } else {
            interpCoords = new Coordinate[numPoints];
        }

        interpCoords[0] = new Coordinate(ctrlCoords[o[0]]);
        interpCoords[interpCoords.length - 1] = new Coordinate(ctrlCoords[o[N - 1]]);

        double curDist = dIncr;
        int kCtrl = 1;
        int kInterp = 1;
        for (int i = 1; i < numPoints - 1; i++, curDist += dIncr) {
            while (curDist > dist[kCtrl]) {
                kCtrl++;
                if (includeCtrlCoords) {
                    interpCoords[kInterp++] = new Coordinate(ctrlCoords[o[kCtrl - 1]]);
                }
            }

            Coordinate c = new Coordinate();

            // locate the x coord of the interpolated point
            double delta = (curDist - dist[kCtrl - 1]) / (dist[kCtrl] - dist[kCtrl - 1]);
            c.x = ctrlCoords[o[kCtrl - 1]].x + delta * xdiff[kCtrl];

            // locate the y coord by evaluating the cubic spline polynomial
            double h = ctrlCoords[o[kCtrl]].x - ctrlCoords[o[kCtrl - 1]].x;
            double a = (ctrlCoords[o[kCtrl]].x - c.x) / h;
            double b = (c.x - ctrlCoords[o[kCtrl - 1]].x) / h;
            c.y = a * ctrlCoords[o[kCtrl - 1]].y + b * ctrlCoords[o[kCtrl]].y +
                    ((a * a * a - a) * ddy[kCtrl - 1] + (b * b * b - b) *
                    ddy[kCtrl]) * (h * h) / 6.0;

            interpCoords[kInterp++] = c;
        }

        return interpCoords;
    }

    /*
     * Get the order of the x ordinates in the given Coordinate array
     */
    private static int[] getXOrder(Coordinate[] coords) {
        if (coords.length == 0) {
            return null;
        } else if (coords.length == 1) {
            return new int[]{0};
        }

        int[] order = new int[coords.length];
        for (int i = 0; i < coords.length; i++) {
            order[i] = i;
        }

        // using shellsort algorithm as modified from Sedgewick 1990...
        // Algorithms in C
        //
        int[] incs = new int[]{
            1391376, 463792, 198768, 86961, 33936, 13776,
            4592, 1968, 861, 336, 112, 48, 21, 7, 3, 1
        };

        int i0, j;
        double v;
        for (int k = 0; k < incs.length; k++) {
            for (int h = incs[k], i = h; i < coords.length; i++) {
                j = i;
                i0 = order[j];
                v = coords[i0].x;
                while (j > h - 1 && coords[order[j - h]].x > v) {
                    order[j] = order[j - h];
                    j -= h;
                }
                order[j] = i0;
            }
        }

        return order;
    }
  }

Geometry
^^^^^^^^

Using Geometry is pretty straight forward, although a little intimidating when starting out due to the number of methods.


.. image:: /images/geometry_use.PNG

Some summary information is available:

* getArea() - area returned in the same units as the coordinates (be careful of lat/lon data!)
* getCentroid() - the centre of the geometry
* getEnvelope() - returns a geometry which is probably not what you wanted
* getEnvelopeInternal() - this returns a useful Envelope
* getInteriorPoint() - the centre of the geometry (that is actually on the geometry)
* getDimension()

Geometry relationships are represented by the following functions returning true or false:

* disjoint(Geometry) - same as "not" intersects
* touches(Geometry) - geometry have to just touch, crossing or overlap will not work
* intersects(Geometry)
* crosses(Geometry)
* within(Geometry) - geometry has to be full inside 
* contains(Geometry)
* overlaps(Geometry) - has to actually overlap the edge, being within or touching will not work
* covers(Geometry)
* coveredBy(Geometry)
* relate(Geometry, String) - allows general check of relationship see dim9 page
* relate(Geometry)

To actually determine a shape based on two geometry:

* intersection(Geometry)
* union(Geometry)
* difference(Geometry)
* symDifference(Geometry)

Some of the most helpful functions are:

* distance( Geometry )
* buffer(double) - used to buffer the edge of a geometry to produce a polygon
* union() - used on a geometry collection to produce a single geometry

The tree most difficult methods are here (they will be discussed in detail):

* equals( Object ) - normal Java equals which checks that the two objects are the same instance
* equals( Geometry ) - checks if the geometry is the same shape
* equalsExact( Geometry ) - check if the data structure is the same
 
There are some book keeping methods to help discovery how the geometry was constructed:

* getGeometryFactory()
* getPreceisionModel()
* toText() - the WKT representation of the Geometry
* getGeoemtryType() - factory method called (ie "point", "linestring", etc..)

A couple of methods are there to store your developer information:

* getSRID() - stores the "spatial reference id", used as an external key when working with databases
* getUserData() - intended to be used by developers, a best practice is to store a java.util.Map. GeoTools will occasionally use this field to store a "srsName" or full CoordianteReferenceSystem. 


Geometries Enum
^^^^^^^^^^^^^^^

Code that makes use of Geometry ends up doing a fair amount of "instanceof" testing in order to determine what kind of Geometry is being used (to take appropriate action).

We have an enumeration defined to help out in this case:
    
   .. literalinclude:: /../src/main/java/org/geotools/geometry/GeometryExamples.java
      :language: java
      :start-after: // geometries start
      :end-before: // geometries end

